/**
 * BacklogItem class, similar to Message class, will be an isolated class to create 
 * backlog objects, without any of the prototypes found in the Backlog class
 */
class BacklogItem {
  /**
   * @param {int} time time - the unix time representation for when the message was retrieved
   * @param {int} ref ref - the associated task ID 
   * @param {int} secRef secRef - the associated secondary task ID 
   * @param {bool} dupe dupe - a boolean value representing whether the task is a duplicate or not
   */
  constructor(time, ref, secRef, dupe) {
    this.time = time || null;
    this.ref = ref || null;
    this.secRef = secRef || null;
    this.dupe = dupe || null
  }
}


/**
 * Backlog class will handle verification either within the incoming messages, in their content;
 * or in comparison to the content found in Sheets
 */
class Backlog {
  constructor() {
    this.databaseBacklog = [];
    this.inputBacklog = [];
    this.inputRefs = [];
    this.inputUnix = [];
    this.comparison

    /**
     * Database method will prepare and initiate a Database lookup based on the already added content
     */
    this.Database = function() {
      this.databaseBacklog = [];
      var blocks;
      
      var db = new Database()
      db.LatestEntry()

      if (db.lastValue != 0 && db.blankRow < 30) {
        blocks = db.CheckBacklog((db.blankRow - 1), (db.blankRow - 2))
        Logger.log("Performing backlog query from rows %s to %s", ((db.blankRow - 1) - (db.blankRow - 2)), (db.blankRow - 1))
      } else if (db.lastValue != 0 && db.blankRow > 30) {
        blocks = db.CheckBacklog((db.blankRow - 1), 30)
        Logger.log("Performing backlog query from rows %s to %s", ((db.blankRow - 1) - 30), (db.blankRow - 1))
      } else {
        Logger.log("Skipping backlog query")
        return
      }
      
      for (var c = 0 ; c < blocks[0].length ; c++) {
        var item = new BacklogItem(
          blocks[0][c],
          blocks[1][c],
          blocks[2][c]
        )
        this.databaseBacklog.push(item)
      }
    }


    /**
     * DatabaseLookup method will take in a Message object and check whether it matches any entries
     * present in the Database backlog previously composed
     * 
     * @param {Object} entry entry - a Message object, generated by MessageBuilder
     */
    this.DatabaseLookup = function(obj) {
      this.databaseBacklog.reverse()
      for (var i = 0; i < this.databaseBacklog.length; i++) {        
        if (
            obj.ref == this.databaseBacklog[i].ref
            &&
            obj.bodyRef == this.databaseBacklog[i].secRef
            &&
            ((this.databaseBacklog[i].time * 1) + 259200000 ) > obj.unix

          ) {
            this.databaseBacklog.reverse()
            return true
          }
      }
      this.databaseBacklog.reverse()
      return false      
    }


    /**
     * InputLookup method will take in a Message object and check whether it matches any entries
     * present in the incoming messages backlog being composed.
     * 
     * If the same task is set to the same owner within 3 days, it's marked as a duplicate. Returns 
     * the found status (boolean) which is then handled to mark the object as such, if needed
     * 
     * @param {Object} entry entry - a Message object, generated by MessageBuilder
     * 
     * @returns {bool} A boolean value whether the object is a duplicate or not
     */
    this.InputLookup = function(entry) {
      var status

      if (!this.inputRefs.includes(entry.ref)) {
        status = false
        var bl = new BacklogItem(
          null,
          null,
          entry.ref,
          entry.unix,
          status
        )
        this.inputRefs.push(entry.ref)
        this.inputUnix.push(entry.unix)    
              
      } else {
        var index = this.inputRefs.lastIndexOf(entry.ref)
        if (((this.inputUnix[index] * 1) + 259200000) > entry.unix) {
          // if the unix time difference is lower than 3 days, the case is a duplicate  
          status = true
          var bl = new BacklogItem(
            null,
            null,
            entry.ref,
            entry.unix,
            status
          )
        } else {
          // if the unix time is greater than 3 days, then the case is not duplicate
          status = false          
          var bl = new BacklogItem(
            null,
            null,
            entry.ref,
            entry.unix,
            status
          )
          this.inputRefs.push(entry.ref)
          this.inputUnix.push(entry.unix)            
        }
      }
      this.inputBacklog.push(bl)
      return status
    }

    /**
     * Comparison method will take in a message ID and compare its unix time to the latest
     * entry's unix time. As this is ensuring sync is OK, returns a boolean value representing 
     * a match
     * 
     * @param {string} msgID msgID - a unique message ID from the latest fetched item 
     * 
     * @returns {bool} A boolean value on whether the comparison is matching (OK) or not.
     */
    this.Comparison = function(msgID) {
      var db = new Database()
      db.LatestEntry()

      if (db.blankRow > 2) {
        var entry = db.GetEntry((db.blankRow - 1))
      }

      var mb = new Mailbox({labelTag: ""})
      var input = mb.GetOneMessage(msgID)

      if (input.unix == entry) {
        return true
      }
      return false
    }

    /**
     * Matcher method will iterate through the provided message ID list
     * and cycle through the Sheets entries as per its index value, going from
     * last to first (newest to oldest); taking note of how many entries aren't 
     * matching the Gmail data, and finally removing them once a match is found 
     * (where the data is expected to be in sync)
     * 
     * @param {string[]} msgIDList msgIDList - a list of message IDs, result from 
     * processing a Gmail label query.
     */    
    this.Matcher = function(msgIDList) {
      var counter = 0
      var mb = new Mailbox({labelTag: ""})
      var db = new Database()
      db.LatestEntry()
      var deletionPoint;
            
      for (var i = msgIDList.length - 1 ; i >= 0; i--) {
        if (i > db.blankRow) {
          continue
        }
        
        var response = mb.GetOneMessage(msgIDList[i])
        var entry = db.GetEntry(i + 2)
        if (!entry) {
          continue
        }

        if (response.unix == entry) {
          break
        } 
        deletionPoint = i + 2
        counter++
      }

      if (counter > 0) {
        db.RemoveBelow(deletionPoint)
        Logger.log(`Removed ${counter} corrupted entries.`)
      }
    }       
  }
}
